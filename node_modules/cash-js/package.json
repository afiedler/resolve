{
  "name": "cash-js",
  "description": "Rethinking the $",
  "author": {
    "name": "Rob Robbins",
    "email": "rob.robb.ns@gmail.com"
  },
  "contributors": [
    {
      "name": "Mike Nelson",
      "email": "get@mikeonrails.com"
    }
  ],
  "licenses": [
    {
      "type": "MIT"
    }
  ],
  "version": "0.3.2",
  "engines": {
    "node": ">=0.2.6"
  },
  "main": "./build/debug/cash",
  "readme": "cash\n====\n\n###What Cash Is Not\nAnother replacement for jQuery. Cash does not attempt to be compatible with the\njQuery API.\n\n###What Cash Is\nA tiny library that absracts some pain points when working with native Javascript\nand DOM.\n\n####Why?\nBecause if you are not supporting bad browsers you do not need the shims that\nwere created to support them.\n\n######Annotated Source\n[Here](http://sudo-js.github.io/cash)\n\n##I Can Haz $?\nCash **does** take the familaiar `$` name as it's global identifier. That's where\nthe similarity ends. The cash `$()` **function** will only accept a DOM node or\nnodeList as an argument. We have standardized ways to search the DOM for elements\nnow, **cash** thinks you should use those.\n\n    // as an example, you have a nodeList\n    var things = document.querySelectorAll('.foo');\n\nPassing the `things` nodeList as an arg to `$()` would result in **cash** storing\nthat list on the **cash** object as `q`, and here's the important part, **as an array**.\n\n    $(things);\n    // now there is a this.q that is an array of DOM elements with a class of foo\n\nIn a familar fashion, calling `$()` will return `$` itself so that chainable stuff\ncan happen. In an unfamiliar fashion however, what is returned **is not a unique instance**.\nThis is paramount to understand. Any call to `$()` simply sets the `q` and returns.\n**That is All**.\n\nLet's say that the `things` nodeList contained 3 `div` elements when it was passed to `$()`.\nThat means that there are 3 elements in the `$.q`.\n\n    $(things);\n    $.q //=> [div, div, div]\n    Array.isArray($.q); //=> true\n\nSince calling `$()` returns `$` though the `q` array is always available in a\nchainable fashion, ready to be used.\n\n    $(things).q.forEach(function(el) {el.classList.remove('foo');})\n\n**NOTE**: Calling $(...) resets the `q` to what you pass in. Sometimes you may\nwant to re-use an existing `q`, but that's not the preferred pattern. All chainable methods\noperate on, and possibly modify the `q`, **including event callbacks**.\n\nIt's not expensive to call `$()` so don't fear to simply reset the `q`.\n\n###Why U No Pass In String?\nIt would not be expensive or bloat the codebase to allow `$()` to take a string then\nperform a querySelectorAll with it, returning that back to `$()`. But I won't. Why?\nOne, it promotes `God Dollar` and that's bad. An 'unscoped' call to `$` is a\n**code smell** and should be rather unwieldy. Two, it's a slippery slope for the\ndollar function to start accepting other args. It accepts a node or a collection\nof them and that's all.\n\n##Chainable Methods\nFunctions that operate on the `q` are what **cash** is all about, which ones to implement will be the \nongoing debate that is the future development of **cash**.\n\n###Call, Collect and Assign\nIn order to keep code creep at a minimum, We are introducing these three methods that allow\nthe invocation of native functionality on the elements in the `q`. What do I mean? Let's take\nthe *Attribute methods for an example. We _could_ write seperate methods for the getting, setting, \nand removal of attributes:\n\n    cash.setAttribute = function(foo, bar) {\n      // set attribute 'foo' to 'bar' on each element in the q \n    };\n    \n    cash.removeAttribute = function(foo) {\n      // remove attribute 'foo' from each element in the q \n    };\n    \n    cash.getAttribute = function(foo) {\n      // collect and return attribute 'foo' from each element in the q \n    };\n    \nInstead we can have a single method capable invoking any of these (or any native \nmethod for that matter):\n\n    // We use the call method, passing the method name we want to invoke\n    // as well as the arguments for it\n    $(foo).call('setAttribute', 'data-foo', 'bar'); // returns cash\n    // the same method for remove\n    $(foo).call('removeAttribute', 'data-foo');\n    // It in worth noting that we will use collect for methods that we expect\n    // to return a value\n    $(foo).collect('getAttribute', 'data-foo'); // retruns an array\n\nIn the same way that we can consolidate the calling of methods on Elements we can\nalso for 'direct assignments' like `checked`, `value` etc...\n\n    $(foo).assign('checked', true);\n\n###Events\nThe familiar `on` and `off` methods are provided as, though event binding is standardized\nnow in all good browsers, unbinding can produce much boilerplate in a large project.\nParticularly in a single-page-app where removing event listeners is paramount.\n\n####on(event, callback[,selector][, data][, cap])\nAdds an event listener to each element in the `q`. Very similar to the jQuery `on`\nmethod with the exception of the order of arguments:\n\n+ **event** A DOM Event name\n+ **callback** A function to be called when the event occurs\n+ **selector** Optional CSS selector allowing delegatation of events to the target element.\n+ **data** Optional object literal passed to the callback as `e.data`\n+ **cap** Optional boolean that, if truthy, will force capture phase to be used.\n\n######delegateTarget\nAll events bound by cash will have a delegateTarget attribute. If a selector was used\n(the event was delegated) the delegateTarget will match the provided selector.\n\n####off(event[, callback][, cap])\nRemoves all events bound to the `event` name, or just the passed in `callback`\n(if present), for each element in the `q`. Maintaining the correct reference to\na `callback` can be ugly so if you are looking to remove a specific `callback` on\nan element for an event which may have many listeners, using a `namespaced event`\nmay be a better choice.\n\nYou may use a `*` event name to capture sets of events. For instance, `*.ns` would\nremove all events which were bound to the `ns` namespace. Similarly `*` would\nremove all events, regardless of event name or namespace.\n\n######Cap'n\nThe `cap` argument will need to be passed for the event to be unbound **if you\npassed the argument when binding it**.\n\nIt is worth nothing that the `blur` and `focus` DOM events do not bubble and therefore\ndo not (normally) work correctly with delegation. You can however use the capture phase\nto remedy this. Cash, if it sees that `on` is being used with either `focus` or\n`blur` **and** there is a `sel` (delegation being used) with force the `cap` arg\nto true (therefore using capture phase). If `off` is called on either `focus` or\n`blur` and you had used delegation you **do not need to pass the cap** argument.\nCash will know to use it for you.\n\n#####Event Namespacing\nSimilar in practice to the jQuery event namespace, you can append a value to an\nevent name (or many of them) as a dot-delimited string:\n\n    $(things).on('click.foo', callback);\n\nThis makes it much simpler to remove a specific callback, say another click event\nlistener had already been added:\n\n    $(things).on('click', anotherCallback);\n\nSimply removing `click` from `things` via `off` would remove both listeners. In a\ncase where you only wanted to remove `callback` and not `anotherCallback` you would\npass the namespaced event name to `off`:\n\n    $(things).off('click.foo');\n\nThere is no need to pass the second argument.\n\n#####Baby You're A *\nThe '*' character has a special meaning for the `off()` method. Passed with a namespace\nit will remove all listeners that share the namespace.\n\n    $(things).off('*.foo');\n\nIn a more drastic move you can remove all listeners simply by passing the *.\n\n    $(things).off('*');\n\n######Caveat\nCash does not override the native event passed to your listeners. This means that\nthe `trigger` method cannot be used to fire **only** a namespaced event.\n\n    $(things).on('click', callback).on('click.foo', fooCallback);\n\nCalling `trigger('click')` on `things` here would call both `callback` and `fooCallback`.\nThe latter would recieve the namespace attached to the event passed to it however, as\n`event.namespace` (it would be 'foo'). The former would not, `event.namespace` would be\nfalsey.\n\n###Traversal\nMethods that alter the `q` based on some DOM related criteria.\n\n####closest(selector)\nFor each element in the `q` traverse upwards to find the first element that matches\nthe given CSS selector. The `q` will be accordingly rehydrated with the found elements.\n\n    $(someInput).closest('form');\n\n####find(selector)\nGiven a CSS selector query each element in the `q` for all matches to that selector.\nRehdrate the `q` with any and all of those matches.\n\n    $(someUl).find('li');\n\n####contains(element)\nQeury each element in the `q` for which contains the passed in element. Reset\nthe `q` with that container if found.\n\n    $(things).contains(someElement);\n\n###Styles\nMethods for the getting or setting of styles.\n\n####offset()\nCalling this method will return a hash of key:value pairs that represent the\nposition in the document of the 'zeroth' element in the `q`. Note that the\n`top` and `left` properties will take into account page[X|Y]Offset and the\n`width` and `height` properties will be rounded.\n\n    $(someElement).offset();\n    // => {top: xx, left: xx, width: xx, left: xx}\n\nNote: `offset` is a getter only.\n\n####setStyle(key|obj[, value])\nSet one, or multiple, style properties on each element in the `q`.\n\nThough you could interact with the `element.style` object directly there are a\nfew reasons that having this method available is advantageous. One, you can pass it\nnumbers and 'px' will be added when appropriate. Two, by passing a hash of key:value\npairs the setting of multiple styles at once is possible.\n\n#####itGoesLikeThis, not-like-this\nwhen passing arguments to the `setStyle` method camel case the keys, do not pass them\n'dasherized`. This applies to both the single key and val case and the hash one.\n\n    // the single style case\n    $(things).css('paddingTop', 10);\n    // multiple\n    $(things).css({paddingTop: 10, marginLeft: 5});\n\n####Height and Width\nTo normalize the different attributes one needs to set on `window`, `document`,\nor an `element` for height, we provide this method. Passed a value (string or number),\n`height` works as a setter for each element in the `q`. If the value is a string cash\nwill not attempt to append the unit of measure for you ('px' for example), if a\nnumber 'px' will be added.\n\n    $(foo).find(bar).height(25);\n\nPassed no value `height` functions as a getter for the zeroth element.\n\n    $(foo).find(bar).height(); //=> 25\n\nWidth is the same as height, except it's spelled differently and gets or sets the width property.\n\n\n####Modular By Design\nRun the Node.js `build` script to put together a concatonated source file.\n\n    node build cash\n\nThe file created will be in the `build/debug` directory.\n\nYou don't like a particular method or set of them? 2k gzipped not small enuff? Make your\nown 'build file' then in 'root'. List modules you want as script tags on a plain old HTML document.\nDon't forget to version your version with a version number as the title of the doc. Also,\nthe name of your HTML file will be the name of the concatonated JS file (with extensions corrected obviously).\nUse it like so:\n\n    node build <filename>\n\nThe '.html' extension is not needed as the builder expects it to be an 'html' file.\n\n###API Summary\n\n#####All Module\n+ call(string[, *args])\n+ collect(string[, *args])\n+ assign(string, argument)\n\n#####Core Module\n+ $(node|nodeList) Note: Does not return a unique instance, simply returns `cash`.\n+ get(number) Note: Can use negative numbers for RTL selection\n+ isObect(argument)\n+ noop\n\n#####Style Module\n+ setStyle(string|object[, string])\n+ offSet() Note: Does not function as a setter.\n\n#####Event Module\n+ off(string[, function, bool]) Note: bool is capture phase support.\n+ on(string, function[, string, object, bool]) Note: The order of arguments and the bool capture phase support.\n+ trigger()\n\n#####Height Width Module\n+ height(string|number)\n+ width()\n\n#####Is Not Module\n+ is(string) Note: Accepts a string argument only.\n+ not(string) Note: Accepts a string argument only.\n\n#####Manipulation Module\n+ createElement(string) Note: Returns `cash` not the created element\n+ remove()\n\n#####Show Hide Module\n+ hide()\n+ show()\n+ toggle()\n\n#####Traversal Module\n+ closest(string)\n+ contains(node) Note: Returns `cash` not the container.\n+ find(string)\n+ parent()\n+ parents()\n\n#####Utils Module\n+ deserialize(object)\n+ extend(object, ...)\n+ matches(element, string)\n+ serialize(object)\n\n#####Xhr Module\n+ getXhr(object)\n",
  "readmeFilename": "README.md",
  "_id": "cash-js@0.3.2",
  "_from": "cash-js@~0.3.2"
}
